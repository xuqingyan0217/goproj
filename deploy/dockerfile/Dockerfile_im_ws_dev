FROM alpine:3.14

# todo:因部分服务采用了配置中心，所以说配置目录的结构会发生变化，如下是做修改，我们采用和项目类似的目录结构，etc下面分为conf和etc

# 添加时区处理，确保服务之间的时间的统一
RUN echo -e "https://mirrors.aliyun.com/alpine/v3.14/main\nhttps://mirrors.aliyun.com/alpine/v3.14/community" > /etc/apk/repositories && \
    apk update &&\
    apk --no-cache add tzdata && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo "Asia/Shanghai" >  /etc/timezone
ENV TZ=Asia/Shanghai

# 声明两个只能在dockerfile中使用的变量，使用后就没了
# 设立这两个变量是为了我们之后修改名称时更加容易，就向前面api和rpc的dockerfile文件一样，二者就是名字不同
ARG SERVER_NAME=im
ARG SERVER_TYPE=ws

#声明两个环境变量，在容器内
# todo: 修改etc为配置目录，conf为配置存储中心目录
ENV RUN_BIN bin/${SERVER_NAME}-${SERVER_TYPE}
# ENV RUN_CONF /${SERVER_NAME}/conf/${SERVER_NAME}.yaml
ENV RUN_ETC /${SERVER_NAME}/etc/etc/${SERVER_NAME}.yaml

# 这个关键词的意思是复制的意思，可以将宿主机中的内容复制到容器中
# 命令 左边是宿主机的目录，右边是容器目录
# todo:修改，增加用于存储配置中心需要存储的文件目录
# RUN mkdir /$SERVER_NAME && mkdir /$SERVER_NAME/bin && mkdir /$SERVER_NAME/conf
RUN mkdir /$SERVER_NAME/ && mkdir /$SERVER_NAME/bin/ && mkdir /$SERVER_NAME/etc/ &&  \
    mkdir /$SERVER_NAME/etc/conf/ && mkdir /$SERVER_NAME/etc/etc/

# 复制编译后的二进制文件
# 将由mk文件编译之后的二进制文件复制到我们新建的目录
COPY ./bin/$SERVER_NAME-$SERVER_TYPE /$SERVER_NAME/bin/

# 复制配置文件，要注意，这里的etc下面多了一个dev，所以说我们可以新建dev目录，同时记得修改user.go内容
# todo: 将原本的conf换成etc，因为它使用了配置中心机制
# COPY ./apps/$SERVER_NAME/$SERVER_TYPE/etc/dev/$SERVER_NAME.yaml /$SERVER_NAME/conf/
COPY ./apps/$SERVER_NAME/$SERVER_TYPE/etc/dev/$SERVER_NAME.yaml /$SERVER_NAME/etc/etc/

# 为二进制提供执行权限
RUN chmod +x /$SERVER_NAME/bin/$SERVER_NAME-$SERVER_TYPE

# 该命令指定容器会默认进入那个目录，如我们每次进入服务器的时候会自动进入root目录一样的作用
# 容器内部就是/user目录下，
WORKDIR /$SERVER_NAME

# 这个命令可以让我们的docker容器在启动的时候就执行下面的命令
# 与CMD不同之处是，在docker run 后跟的命令不能替换它，它仍然会启动的时候执行
# ENTRYPOINT ["$RUN_BIN", "-f", "$RUN_CONF"] // 这种写法不支持对环境变量的解析，
#您正在使用ENTRYPOINT 的exec形式。与shell表单不同，exec表单不会调用命令shell。这意味着正常的外壳处理不会发生。例如，ENTRYPOINT [ "echo", "$HOME" ]
# 将不会在$ HOME上进行变量替换。如果要进行shell处理，则可以使用shell形式或直接执行shell，例如：ENTRYPOINT [ "sh", "-c", "echo $HOME" ]。
#当使用exec表单并直接执行shell时（例如在shell表单中），是由shell进行环境变量扩展，而不是docker。（来自Dockerfile参考）
#

ENTRYPOINT $RUN_BIN -f $RUN_ETC
